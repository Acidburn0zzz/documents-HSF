\documentclass[12pt,a4paper]{article}

% Variables that controls behaviour
\usepackage{ifthen} % for conditional statements
\newboolean{pdflatex}
\setboolean{pdflatex}{true} % False for eps figures 

\newboolean{inbibliography}
\setboolean{inbibliography}{false} %True once you enter the bibliography
%https://4e49633d0951e732a4b4-e055a20cd140c2a2b51d085d456340d1.ssl.cf5.rackcdn.com/kyczzsrnjkkf/page/f3ecf59ad94a62d438bfcb00fcc1d00be6852995.jpeg

\textheight=230mm
\textwidth=160mm
\oddsidemargin=7mm
\evensidemargin=-10mm
\topmargin=-10mm
\headsep=20mm
\columnsep=5mm
\addtolength{\belowcaptionskip}{0.5em}

\renewcommand{\textfraction}{0.01}
\renewcommand{\floatpagefraction}{0.99}
\renewcommand{\topfraction}{0.9}
\renewcommand{\bottomfraction}{0.9}

\setlength{\hoffset}{-2cm}
\setlength{\voffset}{-2cm}

% Page defaults ...
\topmargin=0.5cm
\oddsidemargin=2.5cm
\textwidth=16cm
\textheight=22cm

% Don't chase after perfection
\raggedbottom
\sloppy

\usepackage{microtype}
\usepackage{lineno}    % Line numbering during drafting
\usepackage{xspace}    % Avoid problems with missing or double spaces after predefined symbold
\usepackage{caption}   % These three command get the figure and table captions automatically small
\renewcommand{\captionfont}{\small}
\renewcommand{\captionlabelfont}{\small}

%% Graphics
\usepackage{graphicx}  % to include figures (can also use other packages)
\usepackage{color}
\usepackage{colortbl}
\usepackage[table]{xcolor} 

%% Math
\usepackage{amsmath} % Adds a large collection of math symbols
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{upgreek} % Adds in support for greek letters in roman typeset

%% fix to allow peaceful coexistence of line numbering and
%% mathematical objects
%% http://www.latex-community.org/forum/viewtopic.php?f=5&t=163
%%
\newcommand*\patchAmsMathEnvironmentForLineno[1]{%
\expandafter\let\csname old#1\expandafter\endcsname\csname #1\endcsname
\expandafter\let\csname oldend#1\expandafter\endcsname\csname
end#1\endcsname
 \renewenvironment{#1}%
   {\linenomath\csname old#1\endcsname}%
   {\csname oldend#1\endcsname\endlinenomath}%
}
\newcommand*\patchBothAmsMathEnvironmentsForLineno[1]{%
  \patchAmsMathEnvironmentForLineno{#1}%
  \patchAmsMathEnvironmentForLineno{#1*}%
}
\AtBeginDocument{%
\patchBothAmsMathEnvironmentsForLineno{equation}%
\patchBothAmsMathEnvironmentsForLineno{align}%
\patchBothAmsMathEnvironmentsForLineno{flalign}%
\patchBothAmsMathEnvironmentsForLineno{alignat}%
\patchBothAmsMathEnvironmentsForLineno{gather}%
\patchBothAmsMathEnvironmentsForLineno{multline}%
\patchBothAmsMathEnvironmentsForLineno{eqnarray}%
}

% Get hyperlinks to captions and in references.
% These do not work with revtex. Use "hypertext" as class option instead.
\usepackage{hyperref}    % Hyperlinks in references
\usepackage[all]{hypcap} % Internal hyperlinks to floats.

% Make this the last packages you include before the \begin{document}
\usepackage{cite} % Allows for ranges in citations
\usepackage{mciteplus}

\usepackage{longtable} % only for template

\usepackage[colorinlistoftodos]{todonotes}

\date{\today}



\begin{document}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\setcounter{footnote}{1}

\begin{titlepage}
\pagenumbering{roman}


\vspace*{-1.5cm}
\centerline{\large THE HEP SOFTWARE FOUNDATION (HSF)}
\vspace*{1.5cm}
\noindent
\begin{tabular*}{\linewidth}{lc@{\extracolsep{\fill}}r@{\extracolsep{0pt}}}

\\
 & & HSF-TN-2015-XXX \\  % ID 
 & & \today \\ % Date - Can also hardwire e.g.: 23 March 2010
 & & \\
% not in paper \hline
\end{tabular*}

\vspace*{4.0cm}

% Title --------------------------------------------------
{\bf\boldmath\huge
\begin{center}
  HSF Packaging Working Group Report
\end{center}
}

\vspace*{2.0cm}

% Authors -------------------------------------------------
% LSK: Note that people should add themselves when they start editing
\begin{center}
L.~Sexton-Kennedy$^1$, B.~Hegner$^2$
\bigskip\\
{\it\footnotesize
$ ^1$FNAL,$^2$CERN 
}
\end{center}

\vspace{\fill}

% Abstract -----------------------------------------------
\begin{abstract}
  \noindent
  The note describes the outcome of the discussions in the HSF Packaging Working Group. 
  It summarizes the discussion on existing configuration and build tools and the possibility to converge on more common solutions.
\end{abstract}

\vspace*{2.0cm}

\vspace{\fill}

{\footnotesize 
\centerline{\copyright~Named authors on behalf of the HSF, licence \href{http://creativecommons.org/licenses/by/4.0/}{CC-BY-4.0}.}}
\vspace*{2mm}

\end{titlepage}
\pagestyle{plain} % restore page numbers for the main text
\setcounter{page}{1}
\pagenumbering{arabic}

\section{Introduction}

Software development in high energy physics follows the paradigm of open-source software (OSS). Experiments as well as the theory community heavily rely on software being developed outside of the field. The number of such third party software (so-called \emph{externals}) used within a given context can easily reach over 100 interdependent software packages.\footnote{ A package in this context is a revision controlled collection of source files including files to provide an implementation of how to build the source into binary products. These can either be object libraries or executables.}
Creating a consistent and working stack out of 100s of packages, on a variety of platforms is a non-trivial task. Within the field multiple technical solutions exist to configure and build those stacks, in the following these will be referred to as \emph{build tools}. 

Furthermore, quite often software has to be ported to new platforms and operating systems and subsequently patches to the individual externals need to be created. This is a manual and time consuming task, requiring a very special kind of expert knowledge.

None of this work is experiment specific and our working group agrees that this effort is being duplicated. The aim of the HSF packaging working group is to see whether a better synergy within the field on porting/patching and build tools is possible. 

This document describes the discussions and findings of the working group.
\subsection{The Working Group}
The working group consisted of members of the HEP community from the energy and intensity frontiers as well as accelerator modeling. The group met in a series of meetings over the months of May and June~\cite{meetings}.
Additional discussions took place via the public \href{https://groups.google.com/forum/#!forum/hep-sf-packaging-wg}{packaging working group mailing list}.

\section{The HEP build and packaging tool landscape}

Software stacks are needed by many organizations most notably HEP experiments.  If a package is authored by the organization it is not considered an external package however it still will need build recipes. Any system that builds external packages into a coherent whole must also be capable of building the internal packages as well.  In the area of external packages it will be useful to distinguish between ``foreign'' and ``domain'' external packages. Domain packages are authored by groups within the field of HEP and therefor the HSF could influence the behavior of the domain packages. The foreign packages have to be dealt with as they exist. Examples of foreign packages include: gcc, fftw3, eigen and lapack. Examples of domain packages include clhep and ROOT. In the following a few of the solutions used within the community are summarized. For more details we refer to the project websites. 

\subsection{Solution 1 -- Worch}
\emph{Worch}\cite{worch} is the build tool being proposed for the DUNE collaboration.  It has been used to build the software suite common to many liquid argon experiments, called larsoft, as well as the experiment specific code that builds on top of larsoft.

\subsection{Solution 2 -- LCGCMake}

\emph{LCGCMake}\cite{lcgcmake} is the build tool used for creating the LCG releases used by the LHC experiments ATLAS and LHCb. It is based on a set of CMake macros and each external package is described using one of these macros in a semi-declarative style. 

\subsection{Solution 3 -- cmsBuild} 

\emph{cmsBuild}\cite{cmsbuild} is the build tool used for making releases of CMSSW for CMS.  It orchestrates the building of the whole stack from the compiler on up on an as needed basis for any particular release/architecture combination.  It is based on rpm build, python scripts, and text files that specify dependencies, library names and other optional information.

\subsection{Solution 4 -- contractor} 
\emph{Contractor} is the build tool used by the accelerator modeling community and was developed for the Synergia project.  The project must support a wide diversity of platforms from laptops to super-computers.  Looking at the requirements of this community and the solutions they chose to meet them should inform the HSF community as we look forward to a time when many more diverse platforms will be need in HEP computing.  Contractor has no external dependencies and is implemented in Python.

\subsection{Solution 5 -- SciSoft (mrb/ups/cetbuildtools)}
MRB is an acronym for Multi-Repository-Build and is used by some of the intensity frontier experiments at FNAL. Unlike other tools in this list it requires ups (an acronym for Unix-Product-Support) to create an environment for it to operate in properly.  cetbuildtools is a set of scripts that drive CMake to build an interdependent set of packages.  The resulting packages are uploaded to a distribution server called SciSoft.


\section{Taxonomy of non-HEP tools}
\subsection{Solution 6 - Homebrew }
\emph{Homebrew}\cite{homebrew} is a MacOS specific build tool. Packages build instructions are declared by writing Ruby classes with a given set of attributes. The feature set of these declarations is similar to those of cmsBuild and lcgcmake. A project fork focuses on the addition of Linux as a supported platform.

\subsection{Solution 7 - Nix }
\emph{Nix}\cite{nix} is a cross-platform build tool. Package build instructions are written in the \emph{Nix expression language}.

\section{Tool Features and Requirements}
We compared the feature set of the tools described. In evaluating them we defined a set of criteria in which to measure the tools against each other. However, one experiment's strict requirement may just be considered a feature for another experiment. In the following we explain the comparison criteria and the situation for the individual tools.

\subsection{Supported Platforms and Environments}
The most basic criterion is the support for the various platforms and environments used in high-energy physics. There are three categories of environments:
\begin{enumerate}
\item \textbf{Linux}
\item \textbf{MacOS X}
\item \textbf{Windows}
\end{enumerate}
The first category is split into several flavours of distributions. The main distribution are the RedHat derived Scientific Linux~\cite{sl} and CentOS~\cite{centos}. Compared to these, Debian~\cite{debian} and Debian based based distributions play a smaller role in computing centres. On desktops, the Debian based Ubuntu~\cite{ubuntu} seems rather popular.  

In addition, multiple hardware architectures are in use or will be in use in the foreseeable future - x86, ARM, PowerPC, MIC, and various dedicated super-computers. Some of them impose the requirement of cross compilation onto the build and packaging solution, which is why the keyword \textbf{Xcompiler} is added to the platform table.
The table~\ref{tab:taxonomyPlatforms} summarizes this information for the tools considered by the working group so far. Both Linux and MacOS X are supported by all of the tools, while Windows is not supported at all. X-compilation does not seem a priority of the projects yet.

\begin{table}
\centering
\begin{tabular}{lcccc}
& Linux & MacOS X & Windows & Xcompiler \\ \hline
cmsBuild & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{red} - & \cellcolor{green} +  \\
Contractor & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{red} - & ?\\
Homebrew & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{red} - & \cellcolor{red} -\\
LCGCMake & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{yellow} o   & \cellcolor{yellow} o \\
Nix & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{yellow} o  & \cellcolor{yellow} o \\
SciSoft &  \cellcolor{green} + & \cellcolor{green} + & \cellcolor{red} - & ? \\
Worch &  \cellcolor{green} + &  \cellcolor{green}  + & \cellcolor{red} -  &  \cellcolor{yellow} o
\end{tabular}
\caption{\label{tab:taxonomyPlatforms}Supported platforms of the different build tools. A yellow ``o'' denotes that the support is untested or not of production quality.}
\end{table}

\subsection{Build and Installation Variants}
One important feature of build tools in HEP is the support for the installation of multiple stacks or package versions in parallel. 
\begin{enumerate}
\item \textbf{Multi-Rel}: The support for building and installing multiple stacks in parallel. This is important if multiple versions of experiment software need to coexist on a given installation.
\item \textbf{Multi-BuildVar}: The support for multiple versions of the same package within the same stack. There are many possible reasons why this maybe needed, what they have in common is the need to specify compiler switches that have to be applied consistently across the build, like a debugging option or a compiler dialect.
\item \textbf{MutiShell-RTE}: The support for setting up the runtime environment for a given stack version, supporting multiple shell flavours.
\item \textbf{Relocation}: Whether the build tool supports the relocation of packages or creates fully relocatable packages.
\end{enumerate}

The assessment of the tools according to these criteria are listed in Table~\ref{tab:taxonomyVariants}.

\begin{table}
\centering
\begin{tabular}{lcccc}
&Multi-Rel & Multi-BuildVar & MultiShell-RTE & Relocation \\ \hline
cmsBuild & \cellcolor{green} +  & \cellcolor{green} + & \cellcolor{green} & \cellcolor{green} + \\
Contractor & \cellcolor{green} + & \cellcolor{green} + & ? & ? \\
Homebrew &  \cellcolor{red} - & \cellcolor{red} -   & \cellcolor{yellow} NA   & \cellcolor{red} -  \\
LCGCMake & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{green} +\\
Nix & \cellcolor{green} + & \cellcolor{red} - & \cellcolor{green} +  & \cellcolor{red} -\\
SciSoft &  \cellcolor{green} + & \cellcolor{green} + &  \cellcolor{green} + & \cellcolor{green} + \\
Worch &  \cellcolor{green} + &  \cellcolor{green}  + &  \cellcolor{green} + &  \cellcolor{green} +
\end{tabular}
\caption{\label{tab:taxonomyVariants}Support for multiple releases and build variants. \emph{NA} denotes that the criteria are not-applicable for homebrew. As it only provides one variant it can rely on default system paths.}
\end{table}

\subsection{Ease of Install and Use}
The criteria in this category are:
\begin{enumerate}
\item \textbf{Depends-On}: the dependencies of the build tool itself.
\item \textbf{Ease-Add-Pkg}: the ease of adding another package to a stack.
\item \textbf{Ease-Bootstrap}: the ease of bootstrapping the build system itself. A prerequisite is the possibility to use it w/o root privileges. 
\item \textbf{Documentation}: existence and quality of documentation
\end{enumerate}

The findings are summarized in Table~\ref{tab:taxonomyUsability}. The dependencies of most of the tools seem well under control. The addition of new packages is of similar complexity in all cases. Only the ease of bootstrapping differs. For most of them it is a simple checkout. However, others like Nix an entire (fake-)root environment is necessary. The documentation of the domain specific packages is in general very poor, the documentation of the non-HEP tools surprisingly good and complete. 

\begin{table}
\centering
\begin{tabular}{lcccc}
&Depends-On & Ease-Add-Pkg & Ease-Bootstrap & Documentation \\ \hline
cmsBuild & \cellcolor{yellow} Python,rpm,apt & \cellcolor{green} spec-file & \cellcolor{yellow} o  & \cellcolor{red} -\\
Contractor &  \cellcolor{green} Python & ? & ?  & \cellcolor{red} -\\
Homebrew & \cellcolor{green} Ruby & \cellcolor{green} Formula & \cellcolor{green} + & \cellcolor{green} + \\
LCGCMake & \cellcolor{green} Python, Cmake & \cellcolor{green} Cmake-macro & \cellcolor{green} + & \cellcolor{yellow} o\\
Nix & \cellcolor{green} Perl & \cellcolor{green} expression & \cellcolor{red} - & \cellcolor{green} +\\
SciSoft &  \cellcolor{green} Cmake & \cellcolor{green} Cmake-macro & \cellcolor{yellow} o & \cellcolor{red} -\\
Worch &   \cellcolor{green} Waf,Python &  \cellcolor{green}  Text-files & \cellcolor{green} + & \cellcolor{yellow} o\\
\end{tabular}
\caption{\label{tab:taxonomyUsability}Ease of use of the various build tools.}
\end{table}

\subsection{Other Criteria}
During the meetings proponents brought up other creiteria that are not so easy to group together.  Some might consider these requirements, other might disagree. For now we've just listed them as ``other''. The criteria in this category are:
\begin{enumerate}
\item \textbf{Performance}: The relevant metrics are a. length of time to build the entire stack, this includes support for parallel builds. b. length of time to incrementally build a developer defined subset of the stack. 
%BH: I merged Parallel + Performance again
\item \textbf{Sys-Reuse}: the ability of the build system to reuse parts of the system software that is being built if desired.
\item \textbf{Community}: whether the tool is used by a wider community or just by one collaboration 
\item \textbf{Unique-IDs}: A method of uniquely identifying a build product such that if it already exists, it does not have to be built again. 
  \item \textbf{VCS-Support} Integrated support for check-out of given tags or branches from the projects’ repositories directly.
\end{enumerate}
The findings are summarized in Table~\ref{tab:taxonomyOthers}. 
\begin{table}
\centering
\begin{tabular}{lcccccc}

&Performance & Sys-Reuse & Community & Unique-IDs & VCS-Support\\ \hline
cmsBuild & \cellcolor{green} + & \cellcolor{red} - & \cellcolor{red} - & \cellcolor{green} +& \cellcolor{green} +  \\
Contractor & ? & ?  & ? & \cellcolor{red} - & ?\\
Homebrew & \cellcolor{green} +  & \cellcolor{green} +  & \cellcolor{green} + & \cellcolor{red} - & \cellcolor{green} + \\
LCGCMake & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{green} + & \cellcolor{green} + \\
Nix & \cellcolor{green} + & \cellcolor{red} -  & ? & \cellcolor{green} + & ? \\
SciSoft & \cellcolor{yellow} o & ? & \cellcolor{green} + & ? & \cellcolor{green}+  \\
Worch & \cellcolor{green} + &  \cellcolor{green} + & \cellcolor{red} -  & \cellcolor{yellow} o & \cellcolor{green} + 
\end{tabular}
\caption{\label{tab:taxonomyOthers}Further considered features of the build tools. Details in the text.}
\end{table}

\section{Sharing of porting/patching -- ``Build recipes''}
At the core of all packaging systems sits the execution of a given set of build instructions for a particular package, so-called \emph{build recipes}. Framed by collaboration-specific pre- and post-processing steps. The behaviour of these build instructions may be platform dependent or they may be influenced by parameters like build type or paths to their dependencies. 

A lot, probably even most of the work in the packaging infrastructures goes into porting software and preparing these \emph{recipes} for the various platform-dependency-compiler-version combinations. When comparing the (implicit) interfaces of the packaging systems towards their individual recipes, they are strikingly similar. Thus starting with sharing these recipes looks like a viable solution. Various options have been discussed on the HSF packaging github tracker~\cite{github:discussion}. A first implementation of this idea was done in the context of the ALICE experiment~\cite{alidist}.

\section{Summary}
Together with most of the software librarians of the HEP community we assessed the existing build and packaging tools. For this we identified 17 criteria, which are however of different importance to different users. The goal was to see whether there is a base for working on a future common build tool. 

While in general of high quality, the non-HEP tools we looked at seem very weak on the support for multi-stack, multi-configuration setups. There are however more tools in the open-source community we did not investigate on yet.
Among the HEP specific tools examined so far, \emph{LCGCMake} currently seems the most suited candidate for generalization. If decided, it could serve as the tool for the \emph{HSF Reference Builds} of the projects participating in the HSF. A more ambitious goal would be finding a common tool for building experiment stacks.

In parallel to the assessment of existing build tools, we discussed the concept of shared \emph{build recipes}. As one o the next steps in the working group we will try to lay this out in more concrete.

\section*{Acknowledgements}
We would like to thank all people participating in the constructive and lively discussions. In particular Jim Amundson, Marco Clemencic, Giulio Eulisse, Ben Morgan, Pere Mato, Shahzad Muzaffar, and Brett Viren. 

\begin{thebibliography}{9}
\bibitem{meetings} Indico agendas of \href{https://indico.cern.ch/event/373973/}{25.2.2015}, \href{https://indico.cern.ch/event/398344/}{2.6.2015}, \href{https://indico.cern.ch/event/400272/}{9.6.2015}, \href{https://indico.cern.ch/event/402229/}{16.6.2015}, \href{https://indico.cern.ch/event/403790/}{23.6.2015}

\bibitem{worch} Worch: \url{https://github.com/brettviren/worch}
\bibitem{lcgcmake} LCGCMake: \url{http://ph-dep-sft.web.cern.ch/document/using-lcgcmake}
\bibitem{cmsbuild} cmsBuild: \url{https://github.com/cmsbuild/cmsdist}
\bibitem{homebrew} Homebrew: \url{http://brew.sh/}
\bibitem{nix} Nix: \url{https://nixos.org/nix/}

\bibitem{sl} Scientific Linux: \url{https://www.scientificlinux.org/}
\bibitem{centos} CentOS: \url{https://www.centos.org/}
\bibitem{debian} Debian: \url{https://www.debian.org/}
\bibitem{ubuntu} Ubuntu: \url{https://www.ubuntu.com/}
\bibitem{github:discussion} Packaging Protocol Discussion:  \url{https://github.com/HEP-SF/packaging/issues/1}
\bibitem{alidist} The alidist package: \url{https://github.com/alisw/alidist}.
\end{thebibliography}

\end{document}